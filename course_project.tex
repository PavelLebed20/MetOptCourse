\documentclass[a4paper,12pt]{article} 

%Параметры страницы
\evensidemargin 5mm \oddsidemargin 5mm \voffset -10mm \textheight 230mm \textwidth 150mm

% Нормальные шрифты
\usepackage{pscyr}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[section]{placeins}
\usepackage[russian]{babel}
\usepackage{mathtext}
\usepackage{changepage}

\begin{document}
\include{titlepage}
\tableofcontents
\listoftables

\newpage

\section{Постановка задачи}
\begin{enumerate}
\item 
Известны: набор инвестиционных проектов $p_{1..n}$, начальное количество денежных средств - s. Каждый проект ${p_i}$ определяется инвестиционной стоимостью - 
${a_i}$ и прибылью - ${b_i}$. Необходимо найти максимальное по прибыли подмножество проектов \{${p_{k_1},...p_{k_m}}$\}, в которые выгоднее всего вложить денежные средства, и для реализации которых суммарно имеется достаточно средств.

\item
Необходимо, чтобы полученно подмножество удовлетворяло логическому условию вида:
\newline
${p_{l_1} \& ...\& p_{l_d}} \Rightarrow$ (${p_{e_1}\vee ... \vee p_{e_w}}$) $ \& $ (${p_{j_1}\vee ...\vee p_{j_z}}$),
\newline
где ${{l_1}...{l_d}}$, ${{e_1}...{e_w}}$, ${{j_1}...{j_z}}$ - не фиксированы (это подмножества {1..n}).  
\item
Для поставленной задачи нужно придумать, обосновать и реализовать алгоритм решения. И представить результаты работы для n = 7.

\end{enumerate}

\section{Формализация задачи}
\begin{enumerate}
\item 
Количество денежные средств положительно, т.о.
\newline   
${a_i}$ > 0, ${b_i}$ > 0, s > 0 $\forall i \in {1..n}$
\item 
Представим множество проектов  \{${p_{1},...p_{n}}$\} как булевый вектор \cite{discr_math}, т.е. $p_{i} \in (0, 1)$, где $p_{i} = 1$, если мы вкладываемся в проект,  $p_{i} = 0$ - если не вкладываемся. $\forall i \in {1..n}$, тогда 
\newline Cтоимость проектов: $c = \sum_{i=1}^{n} p_{i} * {a_i}$
\newline Прибыль проектов: $nvp = \sum_{i=1}^{n} p_{i} * {b_i}$
\newline В заданных обозначениях должно выполнятся $ c \leq s $, где $s$ - начальное количество денежных средств
\item 
Условия вида \newline
${p_{l_1} \& ...\& p_{l_d}} \Rightarrow$ (${p_{e_1}\vee ... \vee p_{e_w}}$) $ \& $ (${p_{j_1}\vee ...\vee p_{j_z}}$)
должны выполнятся по правилам булевой алгебры \cite{discr_math}
\end{enumerate}
Т.о. образом, необходимо найти max: $nvp = \sum_{i=1}^{n} p_{i} * {b_i}$, при услвоиях:
\begin{enumerate}
\item
$c = \sum_{i=1}^{n} p_{i} * {a_i} \leq s$, где $s$ - начальное количество денежных средств
\item
${p_{l_1} \& ...\& p_{l_d}} \Rightarrow$ (${p_{e_1}\vee ... \vee p_{e_w}}$) $ \& $ (${p_{j_1}\vee ...\vee p_{j_z}}$)	
\end{enumerate}

\section{Анализ задачи}
Первый пункт поставленной задачи эквивалентен "задаче об упаковке рюкзака". \cite{discr_math} (В этой задаче необхожимо уложить в рюкзак максимальные по суммарной стоимости предметы, т.к. чтобы суммарный вес не превышал максимальной вместимости (по весу) рюкзака. В исходной задаче вместо стоимости предметов - прибыль от инвестиции в проект, а вместо вместимости рюкзака - начальные денежные средства). Эта задача пинадлежит к NP-полным, т.о. она не известно решение за полиномиальное время. Задача решается следующими методами \cite{discr_math}:
\begin{enumerate}
\item 
С применением динамического программирования со сложностью O(NW).
\item 
Перебором (например, с использованием метода ветвей и границ) со сложностью O($2^{N}$).
\end{enumerate}
Сущестенным является наличие второго условия (логического). Оно не позволяет использовать метод динамического программирования, т.к. не гарантируется, что 
результат будет ему удовлетворять. А перерасчет максимального значения после проверки приведет к полному перебору в худшем случае. Т.о. образом необходимо
предварительно найти все множества вида  \{${p_{1},...p_{n}}$\}, где $p_{i} \in (0, 1)$, которые будут удовлетворять логическому условию. Построение таблицы истинности \cite{discr_math} имеет сложность O($2^{N}$). (Фактически перебираются все возможные подмножества n-го булева пространства). Значит, решение задачи будем проводить перебором.

\section{Алгоритм}
Перебирвем все подмножества булева  n-го булева пространства. Для каждого булева вектора проверяем выполнения логического условия. Если условие выполняется, 
считаем значения стоимости проекта и прибыли проекта. Если стоимости проекта не больше начального количества денежных средств, считаем прибыль проектов и 
добавляем в множество возможных по логическому условию проектов. Из множества возможных по логическому условию проектов выбираем наибольшее по прибыли значение. Это значение и соответствующий ему булевый вектор - ответ. Если получившееся множество пустое, значит не существует подмножества проектов, в которые при заданных условиях можно вложиться.

\section{Обоснование алгоритма}
Т.к. перебор осуществляется по всем вариантам, из которых выбирается максимальное по прибыли значение - алгоритм решит задачу.

\section{Сложность алгоритма}
Перебор всех векторов n-го булева пространства - $2^{N}$ шагов. Действительно, каждый элемент вектора может принимать одно из двух значений. 
Порядок следования элементов существенен. Т.о. $\widetilde{P}(2, n) = 2^{n}$ (Число размещений с повторениями \cite{discr_math}). При этом на каждом шаге считаются суммы $c = \sum_{i=1}^{n} p_{i} * {a_i}$, $nvp = \sum_{i=1}^{n} p_{i} * {b_i}$ - 2 * n шагов. Т.о. сложность алгоритма - O($2^{N} * N$).

\section{Вычисление логического условия}
${p_{l_1} \& ...\& p_{l_d}} \Rightarrow$ (${p_{e_1}\vee ... \vee p_{e_w}}$) $ \& $ (${p_{j_1}\vee ...\vee p_{j_z}}$)
\newline Логическое выражение типа следствие имеет следующу таблицу истинности
\begin{table}[h]
	\caption{$x_1 \Rightarrow x_2$}
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\hline
			$x_1$ & $x_2$ & Значение \\
			\hline
			0 & 1 & 1 \\
			\hline
			0 & 0 & 1 \\
			\hline
			1 & 0 & 0 \\
			\hline
			1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
\end{table}
\newline ${p_{l_1} \& ...\& p_{l_d}} = 1 \Leftarrow \Rightarrow x_i = 1  \forall i \in {l_1..l_d}$
\newline ${p_{e_1} \vee ...\vee p_{e_w}} = 1 \Leftarrow \Rightarrow \exists i \in {e_1..e_w}: x_i = 1$
\newline Множества ${{l_1}...{l_d}}$, ${{e_1}...{e_w}}$, ${{j_1}...{j_z}}$ задаем как индексы исходного множества.
$\forall $ булева вектора вида $ {p_{1},...p_{n}}$
\begin{enumerate}
\item 
Вычисляем значение левой части выражения следствия: для этого проверяем в булевом векторе по индексам ${{l_1}...{l_d}}$ есть ли значение 0, если есть - выражение имеет значение 0, иначе - 1. Если значение 0, то согласно таблице исинности для следствия - ответ 1, иначе - левая часть имет значение 1.
\item 
Вычисляем значение правой части выражения следствия: для этого проверяем в булевом векторе по индексам ${{{e_1}...{e_w}}}$, ${{j_1}...{j_z}}$ для каждого выражения в скобках есть ли значение 1, если есть - выражение имеет значение 1, иначе - 0. Если оба значения в скобках 1, то правая часть имеет значение - 1, иначе - 0. Ответ в данном случае = выражение правой части.
\end{enumerate}
Сложность вычисления логического условия не превосходит 3 * n шагов.
\section{Пример решения задачи для n = 7}
Исходные данные:
Наличных средств - 100, размерность n = 7, вектор стоимочтей проектов \{30, 20, 10, 10, 20, 50, 50\}, вектор прибылей проектов \{54, 56, 12, 1, 23, 60, 59\}.
Индексы в левом выражении \{1, 2\}, индексы первого выражения в правой части \{3, 5, 6\}, индексы второго выражения в правой части \{7, 4\}.
\newline Условие имеет вид $p_1 \& p_2 \Rightarrow (p_3 \vee p_5 \vee p_6) \& (p_7 \vee p_4)$
\newline Результат \{0, 1, 1, 0, 1, 1, 0\}, стоимость проектов - 100, прибыль - 151.
Подставляя, для проверки, результат в выражение получаем:
\newline $0 \& 1 \Rightarrow (1 \vee 1 \vee 1) \& (0 \vee 0) = 1$
\newline В результате, перебрано 128 = $2^7$ вариантов.

\section{Программа, решающая поставленную задачу}
Работа выполнена на языке Python. Исходный код находится по адресу:
\newline https://github.com/PavelLebed20/MetOptCourse/

\section{Выводы}
Дополнительное логическое условие существенно при выборе алгоритма решения. Решение имеет большую алгоритмическую сложность O($2^{N}$).
Так при размерности задачи n = 48 на современном процессоре (тактовая частота 3.5 Ггц) вычисление займет больше сотни лет. При этом для ускорения алгоритм можно распараллелить. Задача при n = 7 рещается за приемлимо быстрое время. Динамическое задание условия по индексам реализовано. Выбор разных наборов индексов может существенно повлиять на ответ. При необходимости алгоритм моджно изменить под любое логическое условие, достаточно уметь вычислять значение на любом булевом векторе. 

\bibliographystyle{acm}
\bibliography{biblio}

\end{document}